---
title: "版本控制(Git)"
date: 2026-01-20
categories: [Computer science]
tags: [Computer science]

---

进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。

## 快照

Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在 Git 的术语里，文件被称作 Blob 对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：

```
<root> (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = "hello world")
|
+- baz.txt (blob, contents = "git is wonderful")
```

这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个 blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。

## 历史记录建模：关联快照

版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过出于种种原因，Git 并没有采用这样的模型。

在 Git 中，历史记录是一个由快照组成的有向无环图，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。在 Git 中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：

```
o <-- o <-- o <-- o
            ^
             \
              --- o <-- o
```

其中的 `o` 表示一次提交（快照）箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样：

```
o <-- o <-- o <-- o <----  o 
            ^            /
             \          v
              --- o <-- o
```

Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。

## 对象和内存寻址

Git 中的对象可以是 blob、树或提交：

```
type object = blob | tree | commit
```

Git 在储存数据时，所有的对象都会基于它们的 [SHA-1 哈希](https://en.wikipedia.org/wiki/SHA-1) 进行寻址。

```python
objects = map<string, object>

def store(object):
    id = sha1(object)
    objects[id] = object

def load(id):
    return objects[id]
```

Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。

```shell
100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo
```

## 引用

给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，`master` 引用通常会指向主分支的最新一次提交。

**PS**:通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。

```shell
commit c39eaaf3f5a5628c721419a15aec3fad5a4e007c (HEAD -> main, origin/main, origin/HEAD)
```

# Git 的命令行接口

## 基础

- `git help <command>`: 获取 git 命令的帮助信息
- `git init`: 创建一个新的 git 仓库，其数据会存放在一个名为 `.git` 的目录下
- `git status`: 显示当前的仓库状态

```shell
oplisty@oplistydeMacBook-Air oplisty.github.io % git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

- `git add <filename>`: 添加文件到暂存区

- ```shell
  git commit
  ```

  : 创建一个新的提交

  - 如何编写 [良好的提交信息](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)!
  - 为何要 [编写良好的提交信息](https://chris.beams.io/posts/git-commit/)

- `git log`: 显示历史日志

- `git log --all --graph --decorate`: 可视化历史记录（有向无环图）

```shell
oplisty@oplistydeMacBook-Air oplisty.github.io % git log --all --graph --decorate 
* commit c39eaaf3f5a5628c721419a15aec3fad5a4e007c (HEAD -> main, origin/main, origin/HEAD)
| Author: oplisty <oplisty@oplistydeMacBook-Air.local>
| Date:   Tue Jan 20 11:33:04 2026 +0800
| 
|     1
| 
* commit 1b8d6a81c1def19ec2cf53fd663f7315af66b6c6
| Author: oplisty <oplisty@oplistydeMacBook-Air.local>
| Date:   Tue Jan 20 11:24:46 2026 +0800
| 
|     1
:
```

- `git diff <filename>`: 显示与暂存区文件的差异

```markdown
diff --git a/_posts/2026-01-20-CS-git.md b/_posts/2026-01-20-CS-git.md
index 788f137..c008a55 100644
--- a/_posts/2026-01-20-CS-git.md
+++ b/_posts/2026-01-20-CS-git.md
@@ -8,3 +8,131 @@ tags: [Computer science]
 
 进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。
 
+## 快照
```

- `git diff <revision> <filename>`: 显示某个文件两个版本之间的差异

```shell
git diff a1b2c3d README.md
```

**看 `README.md` 相对上一个提交（`a1b2c3d`）改了什么**

- `git checkout <revision>`: 更新 HEAD（如果是检出分支则同时更新当前分支）
  1. 检出某个提交（进入 detached HEAD）

```shell
git checkout a1b2c3d
```

- HEAD 指向提交 `a1b2c3d`
- 工作区文件会变成那次提交的内容
- 你不再“在某个分支上”（detached HEAD）
- 这时候可以查看、编译、运行、做临时修改；但如果要保留修改，最好新建分支：

```shell
git checkout -b debug-old-state
```

​     2. 检出某个分支（HEAD 跟着分支走，同时切换当前分支）

```
git checkout feature/login
```

- HEAD 指向 `feature/login` 分支的最新提交
- 当前分支变成 `feature/login`
- 工作区更新为该分支内容

     3.  把某个文件恢复到某个版本（只影响文件，不切换分支）

```shell
git checkout HEAD~1 -- README.md
```

效果：

- 只把 `README.md` 恢复成上一个提交里的版本
- 其它文件和分支不变
- 恢复后这个变化会出现在工作区/暂存区里（你可以再 `git add` / `git commit`）
